<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FUSION ULTRA</title>
  <link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  <style>
    :root {
      --primary: #FFD700;
      --secondary: #00E676;
      --danger: #FF5252;
      --info: #40C4FF;
      --dark: #121212;
      --light: rgba(255, 255, 255, 0.9);
      --glass: rgba(15, 15, 15, 0.75);
      --glass-border: rgba(255, 255, 255, 0.15);
      --glass-light: rgba(255, 255, 255, 0.05);
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: 'El Messiri', sans-serif, Arial, Helvetica; 
    }
    
    body {
      background: #000 url('https://i.ibb.co/LdtcbSLX/74f09d279fb2e94226b2a889cac0a976.jpg') no-repeat center center/cover;
      background-color: #000;
      color: #fff;
      min-height: 100vh;
      overflow-x: hidden;
      line-height: 1.6;
    }
    
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.8;
    }
    
    .container {
      max-width: 850px;
      margin: 3vh auto;
      background: var(--glass);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: 24px;
      padding: 35px;
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6);
      border: 1px solid var(--glass-border);
      animation: fadeIn 0.8s ease-out;
      position: relative;
      overflow: hidden;
    }
    
    .container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--primary), transparent);
      opacity: 0.3;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .header {
      text-align: center;
      margin-bottom: 35px;
      position: relative;
      padding-bottom: 15px;
    }
    
    h1 {
      font-size: 2.8rem;
      margin-bottom: 10px;
      color: var(--primary);
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
      position: relative;
      display: inline-block;
      letter-spacing: 1px;
    }
    
    h1::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--primary), transparent);
      border-radius: 3px;
      opacity: 0.7;
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: 1fr;
      gap: 30px;
      margin-bottom: 35px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 20px;
    }
    
    .stat-card {
      background: rgba(0, 0, 0, 0.35);
      padding: 22px;
      border-radius: 18px;
      text-align: center;
      font-size: 1.15rem;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }
    
    .stat-card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: currentColor;
      opacity: 0.2;
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
      border-color: var(--glass-light);
    }
    
    .stat-card span {
      display: block;
      font-size: 2rem;
      margin-top: 10px;
      font-weight: 600;
      letter-spacing: 1px;
    }
    
    .win-stat { color: var(--secondary); }
    .loss-stat { color: var(--danger); }
    .rate-stat { color: var(--info); }
    .server-stat { color: var(--primary); }
    
    .prediction-card {
      background: rgba(0, 0, 0, 0.45);
      padding: 30px;
      border-radius: 18px;
      text-align: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      border: 1px solid var(--glass-border);
      margin-top: 10px;
      transition: var(--transition);
    }
    
    .prediction-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.3);
    }
    
    .prediction-info {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .period-display {
      font-size: 1.3rem;
      color: var(--light);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .period-display i {
      color: var(--primary);
      opacity: 0.8;
    }
    
    .prediction-display {
      font-size: 1.7rem;
      font-weight: 700;
      padding: 12px 25px;
      border-radius: 30px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid var(--glass-border);
      letter-spacing: 1px;
      transition: var(--transition);
    }
    
    .big-prediction {
      color: var(--secondary);
      border-color: rgba(0, 230, 118, 0.3);
      background: rgba(0, 230, 118, 0.1);
      text-shadow: 0 0 10px rgba(0, 230, 118, 0.3);
    }
    
    .small-prediction {
      color: var(--danger);
      border-color: rgba(255, 82, 82, 0.3);
      background: rgba(255, 82, 82, 0.1);
      text-shadow: 0 0 10px rgba(255, 82, 82, 0.3);
    }
    
    .pending-prediction {
      color: var(--light);
      border-color: var(--glass-border);
    }
    
    .countdown {
      margin-top: 20px;
      font-size: 1.1rem;
      color: var(--light);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .countdown i {
      color: var(--primary);
      opacity: 0.8;
    }
    
    .history-section {
      background: rgba(0, 0, 0, 0.35);
      padding: 30px;
      border-radius: 18px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
    }
    
    .history-section:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.3);
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    h2 {
      font-size: 1.6rem;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    h2 i {
      color: var(--primary);
      opacity: 0.8;
    }
    
    .clear-btn {
      background: rgba(255, 82, 82, 0.15);
      color: var(--danger);
      border: 1px solid rgba(255, 82, 82, 0.3);
      padding: 10px 18px;
      border-radius: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: var(--transition);
      font-size: 1rem;
      outline: none;
    }
    
    .clear-btn:hover {
      background: rgba(255, 82, 82, 0.25);
      transform: translateY(-2px);
    }
    
    .clear-btn:active {
      transform: translateY(0);
    }
    
    .confirm-clear {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: var(--transition);
    }
    
    .confirm-clear.active {
      opacity: 1;
      visibility: visible;
    }
    
    .confirm-box {
      background: var(--glass);
      padding: 30px;
      border-radius: 18px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6);
      border: 1px solid var(--glass-border);
      transform: translateY(20px);
      transition: var(--transition);
    }
    
    .confirm-clear.active .confirm-box {
      transform: translateY(0);
    }
    
    .confirm-box h3 {
      color: var(--primary);
      margin-bottom: 20px;
      font-size: 1.4rem;
    }
    
    .confirm-box p {
      margin-bottom: 25px;
      color: var(--light);
    }
    
    .confirm-btns {
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    
    .confirm-btn {
      padding: 10px 25px;
      border-radius: 24px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 600;
      border: none;
    }
    
    .confirm-yes {
      background: var(--danger);
      color: white;
    }
    
    .confirm-no {
      background: rgba(255, 255, 255, 0.1);
      color: var(--light);
    }
    
    .confirm-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    #historyList {
      max-height: 320px;
      overflow-y: auto;
      padding-right: 10px;
      scrollbar-width: thin;
      scrollbar-color: var(--primary) rgba(0, 0, 0, 0.1);
    }
    
    #historyList::-webkit-scrollbar {
      width: 8px;
    }
    
    #historyList::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    
    #historyList::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 10px;
      opacity: 0.5;
    }
    
    .history-item {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 12px;
      padding: 15px 20px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1.05rem;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
    }
    
    .history-item:hover {
      transform: translateX(5px);
      background: rgba(0, 0, 0, 0.35);
      box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
    }
    
    .history-period {
      font-weight: 500;
      color: var(--light);
      flex: 1;
    }
    
    .history-prediction {
      font-weight: 500;
      margin: 0 15px;
      text-align: center;
      flex: 1;
    }
    
    .history-result {
      font-weight: 600;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.95rem;
      min-width: 80px;
      text-align: center;
      transition: var(--transition);
    }
    
    .win { 
      background: rgba(78, 255, 160, 0.15);
      color: var(--secondary);
      border: 1px solid rgba(0, 230, 118, 0.3);
    }
    
    .loss { 
      background: rgba(255, 111, 111, 0.15);
      color: var(--danger);
      border: 1px solid rgba(255, 82, 82, 0.3);
    }
    
    .pending { 
      background: rgba(204, 204, 204, 0.15);
      color: #ccc;
      border: 1px solid rgba(204, 204, 204, 0.3);
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; text-shadow: 0 0 8px currentColor; }
      100% { opacity: 0.6; }
    }
    
    .status-connected {
      color: var(--secondary) !important;
    }
    
    .status-disconnected {
      color: var(--danger) !important;
    }
    
    /* Glow effect for important elements */
    .glow {
      animation: glow 3s ease-in-out infinite alternate;
    }
    
    @keyframes glow {
      from {
        text-shadow: 0 0 5px currentColor;
      }
      to {
        text-shadow: 0 0 15px currentColor;
      }
    }
    
    /* Responsive adjustments */
    @media (max-width: 900px) {
      .container {
        max-width: 95%;
        margin: 2vh auto;
        padding: 25px;
      }
      
      h1 {
        font-size: 2.3rem;
      }
      
      .prediction-info {
        flex-direction: column;
        gap: 20px;
      }
      
      .prediction-display {
        width: 100%;
      }
    }
    
    @media (max-width: 768px) {
      .container {
        border-radius: 18px;
        padding: 20px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .stats-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .stat-card {
        padding: 18px;
      }
      
      .history-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 15px;
      }
      
      .history-prediction, .history-result {
        align-self: flex-end;
        margin: 0;
      }
    }
    
    @media (max-width: 480px) {
      .container {
        margin: 1vh auto;
        padding: 15px;
        border-radius: 15px;
      }
      
      h1 {
        font-size: 1.8rem;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
      }
      
      .stat-card {
        padding: 15px;
      }
      
      .prediction-card {
        padding: 20px;
      }
      
      .prediction-display {
        font-size: 1.4rem;
        padding: 10px 20px;
      }
      
      .history-section {
        padding: 20px;
      }
      
      .confirm-box {
        padding: 20px;
      }
      
      .confirm-btns {
        flex-direction: column;
        gap: 10px;
      }
    }
    
    /* Loading animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  <div class="container">
    <div class="header">
      <h1 class="glow">FUSION ULTRA</h1>
    </div>
    
    <div class="dashboard">
      <div class="stats-grid">
        <div class="stat-card win-stat">
          <i class="fas fa-trophy"></i> Wins <span id="totalWins">0</span>
        </div>
        <div class="stat-card loss-stat">
          <i class="fas fa-times-circle"></i> Losses <span id="totalLosses">0</span>
        </div>
        <div class="stat-card rate-stat">
          <i class="fas fa-chart-line"></i> Win Rate <span id="winRate">0.00%</span>
        </div>
        <div class="stat-card server-stat">
          <i class="fas fa-plug"></i> Status <span id="serverStatus" class="pulse">Connecting...</span>
        </div>
      </div>
      
      <div class="prediction-card">
        <div class="prediction-info">
          <div class="period-display">
            <i class="fas fa-calendar-alt"></i> <span id="currentPeriod">Loading...</span>
          </div>
          <div class="prediction-display pending-prediction" id="predictionDisplay">
            <div class="loading-spinner"></div> Loading...
          </div>
        </div>
        <div class="countdown">
          <i class="fas fa-clock"></i><span id="countdown">60</span>s
        </div>
      </div>
    </div>
    
    <div class="history-section">
      <div class="section-header">
        <h2><i class="fas fa-history"></i>History</h2>
        <button class="clear-btn" id="clearBtn" aria-label="Clear prediction history">
          <i class="fas fa-trash-alt"></i> Clear History
        </button>
      </div>
      <div id="historyList">
        <div class="history-item">
          <div class="history-period">Loading history...</div>
          <div class="history-prediction"></div>
          <div class="history-result pending">LOADING</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Clear History Confirmation Modal -->
  <div class="confirm-clear" id="confirmClear">
    <div class="confirm-box">
      <h3>Clear History</h3>
      <p>Are you sure you want to clear all prediction history? This action cannot be undone.</p>
      <div class="confirm-btns">
        <button class="confirm-btn confirm-yes" id="confirmYes">Yes, Clear</button>
        <button class="confirm-btn confirm-no" id="confirmNo">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const apiURL = "https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList";
    const backupAPI = "https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json";
    let historyData = [], lastPeriod = null;
    let winCount = 0, lossCount = 0;
    let countdownInterval, predictionInterval;
    let countdown = 60;

    // Initialize particles.js with enhanced configuration
    function initParticles() {
      particlesJS('particles-js', {
        "particles": {
          "number": {
            "value": 100,
            "density": {
              "enable": true,
              "value_area": 1000
            }
          },
          "color": {
            "value": ["#FFD700", "#00E676", "#40C4FF", "#FF5252"]
          },
          "shape": {
            "type": "circle",
            "stroke": {
              "width": 0,
              "color": "#000000"
            },
            "polygon": {
              "nb_sides": 5
            }
          },
          "opacity": {
            "value": 0.7,
            "random": true,
            "anim": {
              "enable": true,
              "speed": 1,
              "opacity_min": 0.1,
              "sync": false
            }
          },
          "size": {
            "value": 4,
            "random": true,
            "anim": {
              "enable": true,
              "speed": 4,
              "size_min": 0.3,
              "sync": false
            }
          },
          "line_linked": {
            "enable": true,
            "distance": 180,
            "color": "#FFD700",
            "opacity": 0.4,
            "width": 1.5
          },
          "move": {
            "enable": true,
            "speed": 3,
            "direction": "none",
            "random": true,
            "straight": false,
            "out_mode": "out",
            "bounce": false,
            "attract": {
              "enable": true,
              "rotateX": 800,
              "rotateY": 1600
            }
          }
        },
        "interactivity": {
          "detect_on": "canvas",
          "events": {
            "onhover": {
              "enable": true,
              "mode": "grab"
            },
            "onclick": {
              "enable": true,
              "mode": "push"
            },
            "resize": true
          },
          "modes": {
            "grab": {
              "distance": 180,
              "line_linked": {
                "opacity": 0.8
              }
            },
            "bubble": {
              "distance": 400,
              "size": 40,
              "duration": 2,
              "opacity": 8,
              "speed": 3
            },
            "repulse": {
              "distance": 200,
              "duration": 0.4
            },
            "push": {
              "particles_nb": 6
            },
            "remove": {
              "particles_nb": 2
            }
          }
        },
        "retina_detect": true
      });
    }

    function digitalRoot(n) {
      while (n > 9) n = n.toString().split('').reduce((a,b)=>a+parseInt(b), 0);
      return n;
    }

    function predictLogic(period) {
      const num = parseInt(period);
      const weight = (num % 10) + (Math.floor(num / 10) % 10);
      const root = digitalRoot(num);
      const score = weight + root;
      return score % 2 === 0 ? 'BIG' : 'SMALL';
    }

    function generatePrediction(period) {
      const logic = predictLogic(period);
      const randomNum = logic === "BIG"
        ? Math.floor(Math.random() * 5) + 5
        : Math.floor(Math.random() * 5);
      return { prediction: logic, number: randomNum };
    }

    function savePrediction(data) {
      localStorage.setItem("predictionData", JSON.stringify(data));
    }

    function loadPrediction() {
      const data = localStorage.getItem("predictionData");
      return data ? JSON.parse(data) : null;
    }

    function updateStats() {
      const total = winCount + lossCount;
      const winRate = total > 0 ? ((winCount / total) * 100).toFixed(2) : "0.00";
      document.getElementById("totalWins").innerText = winCount;
      document.getElementById("totalLosses").innerText = lossCount;
      document.getElementById("winRate").innerText = winRate + "%";
      
      // Save stats to localStorage
      localStorage.setItem("gameStats", JSON.stringify({
        wins: winCount,
        losses: lossCount
      }));
    }

    function loadStats() {
      const stats = localStorage.getItem("gameStats");
      if (stats) {
        const { wins, losses } = JSON.parse(stats);
        winCount = wins || 0;
        lossCount = losses || 0;
        updateStats();
      }
    }

    function updateHistoryDisplay() {
      const list = document.getElementById("historyList");
      if (historyData.length === 0) {
        list.innerHTML = '<div class="history-item"><div class="history-period">No history data available</div></div>';
        return;
      }
      
      list.innerHTML = historyData.map(h => `
        <div class="history-item">
          <div class="history-period">${h.period}</div>
          <div class="history-prediction">${h.prediction} ${h.number}</div>
          <div class="history-result ${h.result.toLowerCase()}">${h.result}</div>
        </div>
      `).join("");
    }

    function updatePredictionDisplay(prediction) {
      const predictionDisplay = document.getElementById("predictionDisplay");
      predictionDisplay.innerHTML = `${prediction.prediction} <strong>${prediction.number}</strong>`;
      
      if (prediction.prediction === "BIG") {
        predictionDisplay.className = "prediction-display big-prediction";
      } else {
        predictionDisplay.className = "prediction-display small-prediction";
      }
    }

    function startCountdown() {
      clearInterval(countdownInterval);
      countdown = 60;
      updateCountdownDisplay();
      
      countdownInterval = setInterval(() => {
        countdown--;
        updateCountdownDisplay();
        
        if (countdown <= 0) {
          clearInterval(countdownInterval);
          countdown = 60;
        }
      }, 1000);
    }

    function updateCountdownDisplay() {
      document.getElementById("countdown").textContent = countdown;
    }

    async function fetchGameResult() {
      try {
        const res = await fetch(apiURL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            pageSize: 10, pageNo: 1, typeId: 1, language: 0,
            random: "4a0522c6ecd8410496260e686be2a57c",
            signature: "334B5E70A0C9B8918B0B15E517E2069C",
            timestamp: Math.floor(Date.now() / 1000)
          })
        });
        
        const serverStatus = document.getElementById("serverStatus");
        serverStatus.innerText = "Connected";
        serverStatus.className = "status-connected";
        
        const data = await res.json();
        const latest = data?.data?.list?.[0];
        
        if (!latest) {
          console.log("No data from primary API, trying backup...");
          return await fetchBackupGameResult();
        }
        
        // SPECIAL FIX FOR 17-DIGIT PERIOD NUMBERS:
        // Extract the numeric portion (last 5 digits) and increment by 1
        const periodStr = latest.issueNumber.toString();
        const basePart = periodStr.slice(0, -5); // First 12 digits (202508041000)
        const sequencePart = periodStr.slice(-5); // Last 5 digits (10228)
        const incrementedSequence = (parseInt(sequencePart) + 1).toString().padStart(5, '0');
        const adjustedPeriod = basePart + incrementedSequence;
        
        return { 
          period: adjustedPeriod, 
          number: parseInt(latest.number) 
        };
      } catch (error) {
        console.error("Primary API error:", error);
        const serverStatus = document.getElementById("serverStatus");
        serverStatus.innerText = "Disconnected";
        serverStatus.className = "status-disconnected";
        
        // Try backup API
        console.log("Trying backup API...");
        return await fetchBackupGameResult();
      }
    }

    async function fetchBackupGameResult() {
      try {
        const timestamp = Date.now();
        const response = await fetch(`${backupAPI}?ts=${timestamp}&pageSize=1`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        const latest = data?.data?.list?.[0];
        
        if (!latest) {
          throw new Error("No data from backup API");
        }
        
        return { 
          period: latest.issueNumber, 
          number: parseInt(latest.number) 
        };
      } catch (e) {
        console.error('Backup API error:', e);
        return null;
      }
    }

    async function fetchPreviousResults() {
      try {
        const timestamp = Date.now();
        const response = await fetch(`${backupAPI}?ts=${timestamp}&pageSize=10`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data?.data?.list || data.data.list.length === 0) {
          console.warn('API returned no history data. Using empty array.');
          return [];
        }
        
        return data.data.list.slice(0, 10); // Return last 10 results
      } catch (e) {
        console.error('Error fetching previous results:', e);
        return []; // Return empty array on error
      }
    }

    async function updatePrediction() {
      try {
        const result = await fetchGameResult();
        if (!result) {
          console.log("No result from API, skipping update");
          return;
        }

        const nextPeriod = (BigInt(result.period) + 1n).toString();
        if (result.period === lastPeriod) {
          console.log("Same period, no update needed");
          return;
        }
        
        lastPeriod = result.period;

        let saved = loadPrediction();
        if (!saved || saved.period !== nextPeriod) {
          const generated = generatePrediction(nextPeriod);
          saved = { 
            period: nextPeriod, 
            prediction: generated.prediction, 
            number: generated.number 
          };
          savePrediction(saved);
          
          // Also save with period key for history lookup
          localStorage.setItem(`prediction_${nextPeriod}`, JSON.stringify(saved));
        }

        document.getElementById("currentPeriod").innerText = saved.period;
        updatePredictionDisplay(saved);

        // Add to history if not already present
        if (!historyData.find(h => h.period === saved.period)) {
          historyData.unshift({ 
            period: saved.period, 
            prediction: saved.prediction, 
            number: saved.number, 
            result: "PENDING" 
          });
          
          // Keep only the last 50 history items
          if (historyData.length > 50) {
            historyData = historyData.slice(0, 50);
          }
          
          updateHistoryDisplay();
        }

        // Check if we have a result for the previous prediction
        const match = historyData.find(h => h.period === result.period);
        if (match && match.result === "PENDING") {
          const actualType = result.number >= 5 ? "BIG" : "SMALL";
          match.result = actualType === match.prediction ? "WIN" : "LOSS";
          
          if (match.result === "WIN") {
            winCount++;
          } else {
            lossCount++;
          }
          
          updateStats();
          updateHistoryDisplay();
        }

        startCountdown();
      } catch (error) {
        console.error("Error in updatePrediction:", error);
      }
    }

    async function initHistory() {
      // Load previous results
      const previousResults = await fetchPreviousResults();
      if (previousResults.length > 0) {
        // Process previous results to initialize win/loss counts
        for (const result of previousResults) {
          const period = result.issueNumber;
          const number = parseInt(result.number);
          const actualType = number >= 5 ? "BIG" : "SMALL";
          
          // Check if we have a prediction for this period in local storage
          const predictionKey = `prediction_${period}`;
          const savedPrediction = localStorage.getItem(predictionKey);
          
          if (savedPrediction) {
            const predData = JSON.parse(savedPrediction);
            const resultType = actualType === predData.prediction ? "WIN" : "LOSS";
            
            if (resultType === "WIN") {
              winCount++;
            } else {
              lossCount++;
            }
            
            historyData.push({
              period: period,
              prediction: predData.prediction,
              number: predData.number,
              result: resultType
            });
          }
        }
        
        // Sort history by period (newest first)
        historyData.sort((a, b) => parseInt(b.period) - parseInt(a.period));
        updateHistoryDisplay();
      }
    }

    function clearHistory() {
      // Clear history data
      historyData = [];
      
      // Clear all prediction history from localStorage
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('prediction_')) {
          localStorage.removeItem(key);
        }
      });
      
      // Reset stats
      winCount = 0;
      lossCount = 0;
      updateStats();
      updateHistoryDisplay();
      
      // Hide confirmation modal
      document.getElementById('confirmClear').classList.remove('active');
    }

    async function init() {
      initParticles();
      loadStats();
      await initHistory();
      
      const stored = loadPrediction();
      if (stored) {
        document.getElementById("currentPeriod").innerText = stored.period;
        updatePredictionDisplay(stored);
        
        if (!historyData.find(h => h.period === stored.period)) {
          historyData.unshift({ 
            period: stored.period, 
            prediction: stored.prediction, 
            number: stored.number, 
            result: "PENDING" 
          });
          updateHistoryDisplay();
        }
      }
      
      updateStats();
      await updatePrediction();
      
      // Update every 6 seconds
      predictionInterval = setInterval(updatePrediction, 6000);
      
      // Clear history button events
      document.getElementById("clearBtn").addEventListener("click", () => {
        document.getElementById('confirmClear').classList.add('active');
      });
      
      document.getElementById("confirmYes").addEventListener("click", clearHistory);
      
      document.getElementById("confirmNo").addEventListener("click", () => {
        document.getElementById('confirmClear').classList.remove('active');
      });
      
      // Close modal when clicking outside
      document.getElementById("confirmClear").addEventListener("click", (e) => {
        if (e.target === document.getElementById("confirmClear")) {
          document.getElementById('confirmClear').classList.remove('active');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
