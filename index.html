<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ZENITH PVT SERVER</title>
    <style>
        @keyframes subtleGlow {
            0% { box-shadow: 0 0 10px rgba(0, 100, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 150, 255, 0.7); }
            100% { box-shadow: 0 0 10px rgba(0, 100, 255, 0.5); }
        }

        body {
            background-color: #0a0e2a;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 80, 200, 0.15) 0%, transparent 30%),
                radial-gradient(circle at 80% 70%, rgba(0, 120, 255, 0.15) 0%, transparent 30%);
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            width: 340px;
            margin: 20px auto;
            min-height: 420px;
            background: linear-gradient(145deg, #0f1a3a, #0a1229);
            border: 2px solid #1a4b8c;
            padding: 25px;
            padding-bottom: 70px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 60, 150, 0.3);
            position: relative;
            animation: subtleGlow 4s ease-in-out infinite;
            backdrop-filter: blur(5px);
        }

        .title, .timer, .period, .bet {
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .title {
            font-size: 32px;
            text-align: center;
            margin-bottom: 25px;
            color: #4d9eff;
            letter-spacing: 1px;
            background: linear-gradient(to right, #4d9eff, #6bb9ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
        }

        .title::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 25%;
            width: 50%;
            height: 2px;
            background: linear-gradient(to right, transparent, #4d9eff, transparent);
        }

        .timer {
            font-size: 52px;
            text-align: center;
            margin-bottom: 25px;
            color: #ffffff;
            font-family: 'Digital', monospace;
            background: rgba(10, 30, 60, 0.4);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(50, 120, 200, 0.3);
        }

        .period {
            font-size: 18px;
            text-align: center;
            margin-bottom: 25px;
            color: #8ab4ff;
            background: rgba(10, 30, 60, 0.3);
            padding: 8px;
            border-radius: 6px;
        }

        .bet {
            font-size: 32px;
            text-align: center;
            margin: 30px 0;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: rgba(10, 30, 60, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(50, 120, 200, 0.2);
        }

        .bet-value {
            font-size: 42px;
            font-weight: 700;
            margin-top: 10px;
            background: linear-gradient(to right, #ff6b6b, #ff8e8e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .button {
            display: block;
            margin: 25px auto;
            width: 180px;
            height: 50px;
            background: linear-gradient(to bottom, #4d9eff, #2a70cc);
            border: none;
            color: white;
            font-size: 18px;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 0 #1a4b8c, 0 5px 15px rgba(0, 80, 180, 0.4);
            position: relative;
            overflow: hidden;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1a4b8c, 0 8px 20px rgba(0, 100, 200, 0.5);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 0 #1a4b8c, 0 3px 10px rgba(0, 80, 180, 0.4);
        }

        .button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -60%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(30deg);
            transition: all 0.3s;
        }

        .button:hover::after {
            left: 100%;
        }

        /* Loading animation */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 1.5s infinite;
            color: #8ab4ff;
        }

        .confidence {
            font-size: 14px;
            margin-top: 10px;
            color: #8ab4ff;
        }

        .watermark {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 10px;
            color: rgba(100, 150, 255, 0.3);
        }
    </style>
</head>
<body>

<div class="container">
    <div class="title">ZENITH PVT SERVER</div>
    <div id="timeRemaining" class="timer">00:03</div>
    <div id="issueNumber" class="period">Period: <span class="loading">Loading</span></div>
    <div id="predictedNumber" class="bet">
        <div id="predictionValue" class="bet-value"><span class="loading">Analyzing</span></div>
        <div id="confidence" class="confidence"></div>
    </div>
    <button id="refreshButton" class="button">CHANGE</button>
    <div class="watermark"></div>
</div>

<script>
// Immediately Invoked Function Expression for better scoping
(function() {
    // DOM elements
    const predictedNumberElement = document.getElementById('predictionValue');
    const timerElement = document.getElementById('timeRemaining');
    const issueNumberElement = document.getElementById('issueNumber');
    const refreshButton = document.getElementById('refreshButton');
    const confidenceElement = document.getElementById('confidence');
    
    // State variables
    let currentIssueNumber = null;
    let timerInterval = null;
    let isFetching = false;
    
    // Constants
    const API_ENDPOINTS = {
        noAverageEmerdList: 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList',
        gameIssue: 'https://api.bdg88zf.com/api/webapi/GetGameIssue'
    };
    
    const REQUEST_CONFIG = {
        noAverageEmerdList: {
            pageSize: 10,
            pageNo: 1,
            typeId: 1,
            language: 0,
            random: "ded40537a2ce416e96c00e5218f6859a",
            signature: "69306982EEEB19FA940D72EC93C62552",
            timestamp: 1721383261
        },
        gameIssue: {
            typeId: 1,
            language: 0,
            random: "e7fe6c090da2495ab8290dac551ef1ed",
            signature: "1F390E2B2D8A55D693E57FD905AE73A7",
            timestamp: 1723726679
        }
    };
    
    // Prediction Logic Functions
    function is_prime(n) {
        if (n <= 1) return false;
        for (let i = 2; i <= Math.sqrt(n); i++) {
            if (n % i === 0) return false;
        }
        return true;
    }

    function logic_euler(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        const total_sum = digits.reduce((a, b) => a + b, 0);
        const total_product = digits.reduce((a, b) => a * b, 1);
        const val = (total_sum + total_product) % 10;
        return { result: val >= 5 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_prime_sum(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        return { result: is_prime(digits.reduce((a, b) => a + b, 0)) ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_odd_even(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        return { result: digits.reduce((a, b) => a + b, 0) % 2 !== 0 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_repeat_pattern(period_number) {
        const digits = period_number.slice(-4).split('');
        return { result: new Set(digits).size <= 2 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_digit_trend(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        const isAscending = digits.every((val, i, arr) => i === 0 || val >= arr[i - 1]);
        const isDescending = digits.every((val, i, arr) => i === 0 || val <= arr[i - 1]);
        return { result: isAscending || isDescending ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_middle_avg(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        const avg = (digits[1] + digits[2]) / 2;
        return { result: avg >= 5 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_trap_avoidance(period_number) {
        const digits = period_number.slice(-4).split('');
        return { 
            result: (digits[0] === digits[3] || digits[1] === digits[2]) ? "SMALL" : "BIG", 
            weight: 1.2 
        };
    }

    function logic_fib_weight(period_number) {
        const fib_weights = [1, 1, 2, 3];
        const digits = period_number.slice(-4).split('').map(Number);
        const total = digits.reduce((acc, val, idx) => acc + val * fib_weights[idx], 0);
        return { result: total % 10 >= 5 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function logic_high_value_count(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        const high_count = digits.filter(d => d >= 7).length;
        return { result: high_count >= 2 ? "BIG" : "SMALL", weight: 1.1 };
    }

    function logic_palindrome(period_number) {
        const s_digits = period_number.slice(-4);
        return { result: s_digits === s_digits.split('').reverse().join('') ? "BIG" : "SMALL", weight: 1.3 };
    }

    function logic_digit_proximity(period_number) {
        const digits = period_number.slice(-4).split('').map(Number);
        if (new Set(digits).size === 1) return { result: "BIG", weight: 1.0 };
        return { result: Math.max(...digits) - Math.min(...digits) <= 2 ? "BIG" : "SMALL", weight: 1.0 };
    }

    function advanced_prediction(period_number) {
        const strategies = [
            logic_euler, logic_prime_sum, logic_odd_even, logic_repeat_pattern,
            logic_digit_trend, logic_middle_avg, logic_trap_avoidance,
            logic_fib_weight, logic_high_value_count, logic_palindrome,
            logic_digit_proximity
        ];

        let big_score = 0;
        let small_score = 0;
        let usedStrategies = [];

        strategies.forEach(strategy => {
            const {result, weight} = strategy(period_number);
            usedStrategies.push({name: strategy.name, result, weight});
            
            if (result === "BIG") {
                big_score += weight;
            } else {
                small_score += weight;
            }
        });

        let finalResult;
        if (big_score > small_score) {
            finalResult = "BIG";
        } else if (small_score > big_score) {
            finalResult = "SMALL";
        } else {
            // Tie breaker
            const trustedStrategies = [logic_euler, logic_prime_sum, logic_fib_weight];
            let tieBreakBig = 0;
            
            trustedStrategies.forEach(strategy => {
                const {result} = strategy(period_number);
                if (result === "BIG") tieBreakBig++;
            });

            finalResult = tieBreakBig >= 2 ? "BIG" : "SMALL";
        }

        const totalScore = big_score + small_score;
        const confidence = finalResult === "BIG" 
            ? Math.round((big_score / totalScore) * 100)
            : Math.round((small_score / totalScore) * 100);

        return {
            prediction: finalResult,
            confidence,
            bigScore: big_score,
            smallScore: small_score,
            strategies: usedStrategies
        };
    }
    
    // Helper functions
    const fetchWithRetry = async (url, options, retries = 3) => {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error('Network response was not ok');
                return await response.json();
            } catch (error) {
                if (i === retries - 1) throw error;
                await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
            }
        }
    };
    
    const formatTime = (ms) => {
        const minutes = String(Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60))).padStart(2, '0');
        const seconds = String(Math.floor((ms % (1000 * 60)) / 1000)).padStart(2, '0');
        return `${minutes}:${seconds}`;
    };
    
    // Main functions
    const updateDataAndPrediction = async () => {
        if (isFetching) return;
        isFetching = true;
        
        try {
            const data = await fetchWithRetry(API_ENDPOINTS.noAverageEmerdList, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(REQUEST_CONFIG.noAverageEmerdList)
            });
            
            if (!data?.data?.list?.length) {
                console.error('No data received for no average EMERD list.');
                return;
            }
            
            const list = data.data.list;
            const newIssueNumber = list[0].issueNumber;
            
            // Run advanced prediction
            const predictionResult = advanced_prediction(newIssueNumber);
            
            // Update UI
            predictedNumberElement.textContent = predictionResult.prediction;
            confidenceElement.textContent = ` ${predictionResult.confidence}%`;
            
            if (currentIssueNumber !== newIssueNumber) {
                currentIssueNumber = newIssueNumber;
                issueNumberElement.textContent = `Period: ${currentIssueNumber}`;
            }
            
            // Store last prediction
            localStorage.setItem('lastPrediction', JSON.stringify({
                issueNumber: currentIssueNumber,
                prediction: predictionResult.prediction,
                confidence: predictionResult.confidence
            }));
            
        } catch (error) {
            console.error('Error in updateDataAndPrediction:', error);
            predictedNumberElement.innerHTML = `<span style="color:orange">Error</span>`;
            confidenceElement.textContent = '';
        } finally {
            isFetching = false;
        }
    };
    
    const updateTimer = async () => {
        try {
            const data = await fetchWithRetry(API_ENDPOINTS.gameIssue, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json;charset=UTF-8',
                    'Accept': 'application/json, text/plain, */*'
                },
                body: JSON.stringify(REQUEST_CONFIG.gameIssue)
            });
            
            if (!data?.data) {
                console.error('No data received for game issue.');
                return;
            }
            
            const { endTime, intervalM, issueNumber } = data.data;
            if (!endTime || !intervalM) {
                console.error('Incomplete data received for game issue.');
                return;
            }
            
            const endDate = new Date(endTime);
            const now = new Date();
            const remainingTimeMs = endDate - now;
            
            if (remainingTimeMs <= 0) {
                timerElement.textContent = "00:00";
                clearInterval(timerInterval);
                
                setTimeout(() => {
                    updateDataAndPrediction();
                    updateTimer();
                    timerInterval = setInterval(updateTimer, 1000);
                }, 3000);
            } else {
                timerElement.textContent = formatTime(remainingTimeMs);
            }
            
            if (currentIssueNumber !== issueNumber) {
                currentIssueNumber = issueNumber;
                issueNumberElement.textContent = `Period: ${currentIssueNumber}`;
            }
            
        } catch (error) {
            console.error('Error in updateTimer:', error);
            timerElement.textContent = "--:--";
        }
    };
    
    // Event Listeners
    refreshButton.addEventListener('click', () => {
        updateDataAndPrediction();
    });
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Load last prediction from localStorage if available
        const lastPrediction = localStorage.getItem('lastPrediction');
        if (lastPrediction) {
            try {
                const parsed = JSON.parse(lastPrediction);
                predictedNumberElement.textContent = parsed.prediction;
                confidenceElement.textContent = `Confidence: ${parsed.confidence}%`;
                issueNumberElement.textContent = `Period: ${parsed.issueNumber}`;
            } catch (e) {
                console.error('Error parsing lastPrediction:', e);
            }
        }
        
        updateDataAndPrediction();
        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);
    });
})();
</script>
</body>
</html>
